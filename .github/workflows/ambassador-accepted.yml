name: "Ambassador Accepted: Post + Export"

on:
  workflow_dispatch:
    inputs:
      label_name:
        description: "Target label"
        required: true
        default: Accepted
        type: string
      dry_run:
        description: "Preview without posting"
        required: true
        default: false
        type: boolean

permissions:
  contents: read
  issues: write

jobs:
  post-and-export:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install deps
        run: pip install requests

      - name: Post message and export CSV
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REPO_FULL: ${{ github.repository }}
          LABEL_NAME: ${{ inputs.label_name }}
          DRY_RUN: ${{ inputs.dry_run }}
        run: |
          python - <<'PY'
          import os, re, csv, sys, requests
          from requests.adapters import HTTPAdapter
          try:
              # urllib3 v1/v2 compatibility
              from urllib3.util.retry import Retry
              try:
                  retry = Retry(
                      total=8,
                      backoff_factor=0.7,
                      status_forcelist=[429,500,502,503,504],
                      allowed_methods=frozenset(["GET","POST","HEAD","OPTIONS"])
                  )
              except TypeError:
                  # Older urllib3 uses method_whitelist
                  retry = Retry(
                      total=8,
                      backoff_factor=0.7,
                      status_forcelist=[429,500,502,503,504],
                      method_whitelist=frozenset(["GET","POST","HEAD","OPTIONS"])
                  )
          except Exception as e:
              print("Retry configuration error:", e, file=sys.stderr)
              retry = None

          token = os.getenv("GITHUB_TOKEN")
          repo_full = os.getenv("REPO_FULL")
          label_name = os.getenv("LABEL_NAME","Accepted")
          dry_run = (os.getenv("DRY_RUN","false").lower()=="true")

          if not token or not repo_full:
              print("Missing GITHUB_TOKEN or REPO_FULL", file=sys.stderr); sys.exit(1)
          owner, repo = repo_full.split("/",1)

          s = requests.Session()
          s.headers.update({
              "Authorization": f"Bearer {token}",
              "Accept": "application/vnd.github+json",
              "X-GitHub-Api-Version": "2022-11-28"
          })
          if retry:
              s.mount("https://", HTTPAdapter(max_retries=retry))

          MESSAGE_TEMPLATE = """Hello {first_name}

You’ve been invited to join the private **Ambassador Program Management Repository**:
👉 [pytorch-fdn/ambassador-program-management](https://github.com/pytorch-fdn/ambassador-program-management/)

Once you accept the invitation, you’ll find important information in the discussion thread — including instructions to submit a new issue using the **“Ambassador Confirmation & Details”** template.

To confirm your participation in the 2025 PyTorch Ambassador Program, please open a new issue using the **“Ambassador Confirmation & Details”** template here:
👉 [Create your confirmation issue](https://github.com/pytorch-fdn/ambassador-program-management/issues/new/choose)

_Completing this step will confirm your role and get you ready for onboarding 🚀_

As part of onboarding, we’ll be hosting a **Kick-Off Call** where we’ll share important program details, expectations, and next steps:

📅 **Date:** Monday, September 8
🕒 **Time:** 5:30 PM CEST / 8:30 AM PDT

Once you confirm your role, you will also receive a calendar invite with the meeting link.

We’re truly excited to welcome you into the PyTorch Ambassador Program and look forward to the impact you’ll continue to make in the community.

Best regards,
The PyTorch PMO
"""

          def api_get(url, **kwargs):
              r = s.get(url, **kwargs)
              if r.status_code != 200:
                  print(f"GET {url} failed: {r.status_code} {r.text}", file=sys.stderr)
                  sys.exit(1)
              return r

          def api_post(url, json):
              r = s.post(url, json=json)
              if r.status_code not in (200,201):
                  print(f"POST {url} failed: {r.status_code} {r.text}", file=sys.stderr)
              return r

          def get_accepted_open_issues():
              # labels param supports comma-separated labels; pass as-is to allow spaces
              url = f"https://api.github.com/repos/{owner}/{repo}/issues"
              params = {"state":"open", "labels":label_name, "per_page":100}
              first = True
              while url:
                  r = s.get(url, params=params if first else None)
                  first = False
                  if r.status_code != 200:
                      print(f"List issues failed: {r.status_code} {r.text}", file=sys.stderr)
                      sys.exit(1)
                  data = r.json()
                  for it in data:
                      if "pull_request" not in it:
                          yield it
                  url = r.links.get("next",{}).get("url")

          def parse_after_label(body:str, label:str):
              # Matches:
              # Label
              # value
              pat = rf"{re.escape(label)}\s*\r?\n([^\n\r]+)"
              m = re.search(pat, body or "", re.IGNORECASE)
              return m.group(1).strip() if m else ""

          def extract_fields(issue):
              body = issue.get("body") or ""
              nominee_name = parse_after_label(body, "Nominee Name")
              nominee_email = parse_after_label(body, "Nominee Email")
              location = parse_after_label(body, "City, State/Province, Country")
              gh_handle = parse_after_label(body, "Nominee's GitHub or GitLab Handle")

              if gh_handle.startswith("http"):
                  m = re.search(r"github\.com/([^/\s]+)", gh_handle, re.IGNORECASE)
                  if m: gh_handle = m.group(1)

              # First name from nominee name; fallback to login
              if nominee_name:
                  first_name = nominee_name.split()[0].strip()
              else:
                  user = issue.get("user") or {}
                  prof_name = (user.get("name") or "").strip()  # usually empty on Issues API
                  first_name = prof_name.split()[0] if prof_name else (user.get("login") or "there")

              return {
                  "issue_number": issue["number"],
                  "first_name": first_name,
                  "nominee_name": nominee_name,
                  "nominee_email": nominee_email,
                  "location": location,
                  "github_handle": gh_handle
              }

          def post_comment(issue_number, body):
              if dry_run:
                  print(f"DRY-RUN: would post to #{issue_number}:\n{body[:300]}...\n---")
                  return
              api_post(f"https://api.github.com/repos/{owner}/{repo}/issues/{issue_number}/comments",
                       json={"body": body})

          rows = []
          count = 0
          any_issues = False
          for issue in get_accepted_open_issues():
              any_issues = True
              data = extract_fields(issue)
              msg = MESSAGE_TEMPLATE.format(first_name=data["first_name"])
              post_comment(data["issue_number"], msg)
              count += 1
              rows.append([
                  data["issue_number"],
                  data["nominee_name"],
                  data["nominee_email"],
                  data["location"],
                  data["github_handle"]
              ])

          if not any_issues:
              print(f"No open issues found with label '{label_name}'.")
          else:
              print(f"Posted to {count} accepted issue(s).")

          out = "accepted_export.csv"
          with open(out, "w", newline="", encoding="utf-8") as f:
              w = csv.writer(f)
              w.writerow(["Issue", "Nominee Name", "Nominee Email", "Location", "GitHub Handle"])
              w.writerows(rows)
          print(f"Exported {len(rows)} row(s) -> {out}")
          PY

      - name: Upload export artifact
        uses: actions/upload-artifact@v4
        with:
          name: accepted_export
          path: accepted_export.csv
