name: "Ambassador comments (decisions only)"

on:
  workflow_dispatch:
    inputs:
      private_repo:
        description: "Private repo containing the CSVs (owner/name)"
        required: true
        default: pytorch-fdn/ambassador-program-management
        type: string
      private_ref:
        description: "Branch/tag/sha of the private repo"
        required: true
        default: main
        type: string
      decision_csv_path:
        description: "Path to decision CSV (Submission ID, Decision, Candidate)"
        required: true
        default: .github/ISSUE_TEMPLATE/dmsap.csv
        type: string
      unlock_locked_issues:
        description: "Temporarily unlock locked issues to post, then re-lock"
        required: true
        default: true
        type: boolean
      dry_run:
        description: "Preview without posting"
        required: true
        default: false
        type: boolean

permissions:
  contents: read
  issues: write

concurrency:
  group: ambassador-comments
  cancel-in-progress: true

jobs:
  comment:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout PUBLIC repo
        uses: actions/checkout@v4

      - name: Checkout PRIVATE repo
        uses: actions/checkout@v4
        with:
          repository: ${{ inputs.private_repo }}
          ref: ${{ inputs.private_ref }}
          token: ${{ secrets.PRIVATE_REPO_TOKEN }}
          path: private-src

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install dependencies
        run: pip install requests

      - name: Post comments from decision.csv
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REPO_FULL: ${{ github.repository }}
          DEC_CSV_ABS: ${{ github.workspace }}/private-src/${{ inputs.decision_csv_path }}
          UNLOCK_LOCKED: ${{ inputs.unlock_locked_issues }}
          DRY_RUN: ${{ inputs.dry_run }}
        run: |
          python - <<'PY'
          import os, csv, re, sys, urllib.parse
          import requests
          from requests.adapters import HTTPAdapter, Retry

          token = os.getenv("GITHUB_TOKEN")
          repo_full = os.getenv("REPO_FULL")
          dec_csv = os.getenv("DEC_CSV_ABS")
          dry_run = (os.getenv("DRY_RUN","false").lower() == "true")
          UNLOCK_LOCKED = (os.getenv("UNLOCK_LOCKED","false").lower() == "true")

          if not token or not repo_full:
              print("Missing GITHUB_TOKEN or REPO_FULL", file=sys.stderr); sys.exit(1)

          owner, repo = repo_full.split("/", 1)

          # session with retries
          s = requests.Session()
          retries = Retry(total=8, backoff_factor=0.7,
                          status_forcelist=[429,500,502,503,504],
                          allowed_methods=["GET","POST","PATCH","DELETE","HEAD","OPTIONS"])
          s.mount("https://", HTTPAdapter(max_retries=retries))
          s.headers.update({"Authorization": f"Bearer {token}",
                            "Accept": "application/vnd.github+json",
                            "X-GitHub-Api-Version": "2022-11-28"})

          def norm_key(x): return re.sub(r"[^a-z0-9]+","",(x or "").strip().lower())

          def get_issue_labels(num):
              r = s.get(f"https://api.github.com/repos/{owner}/{repo}/issues/{num}/labels?per_page=100")
              if r.status_code==200: return {x["name"] for x in r.json()}
              print(f"Warn: get labels #{num} failed: {r.status_code} {r.text}"); return set()

          def is_locked(num):
              r = s.get(f"https://api.github.com/repos/{owner}/{repo}/issues/{num}")
              if r.status_code == 200:
                  j = r.json()
                  return bool(j.get("locked")), j.get("active_lock_reason")
              print(f"Warn: GET issue #{num} failed: {r.status_code} {r.text}")
              return False, None

          def unlock_issue(num):
              if dry_run:
                  print(f"DRY-RUN: would UNLOCK issue #{num}")
                  return True
              r = s.delete(f"https://api.github.com/repos/{owner}/{repo}/issues/{num}/lock")
              if r.status_code in (200,204):
                  return True
              print(f"Warn: UNLOCK failed for #{num}: {r.status_code} {r.text}")
              return False

          def relock_issue(num, reason):
              if dry_run:
                  print(f"DRY-RUN: would RE-LOCK issue #{num} (reason={reason or 'none'})")
                  return True
              payload = {"lock_reason": reason} if reason else {}
              r = s.put(f"https://api.github.com/repos/{owner}/{repo}/issues/{num}/lock", json=payload)
              if r.status_code in (200,204):
                  return True
              print(f"Warn: RE-LOCK failed for #{num}: {r.status_code} {r.text}")
              return False

          def add_comment_once(num, body, marker):
              # 1) avoid duplicate comments using hidden marker
              url = f"https://api.github.com/repos/{owner}/{repo}/issues/{num}/comments?per_page=100"
              while url:
                  r = s.get(url)
                  if r.status_code!=200:
                      print(f"Warn: list comments #{num} failed: {r.status_code} {r.text}")
                      break
                  if any(marker in (c.get("body") or "") for c in r.json()):
                      print(f"Skip duplicate comment on #{num}")
                      return
                  url = r.links.get("next",{}).get("url")

              # 2) try to comment
              if dry_run:
                  print(f"DRY-RUN: would comment on #{num}:\n{body}\n---")
                  return
              r = s.post(f"https://api.github.com/repos/{owner}/{repo}/issues/{num}/comments", json={"body": body})
              if r.status_code in (200,201):
                  return

              # 3) if locked and allowed, unlock -> comment -> re-lock
              if r.status_code == 403 and "locked" in (r.text or "").lower():
                  if not UNLOCK_LOCKED:
                      print(f"Locked: #{num} (skipping; set UNLOCK_LOCKED=true to unlock temporarily).")
                      return
                  locked, reason = is_locked(num)
                  if not locked:
                      print(f"Comment 403 but issue #{num} not reported locked; skipping.")
                      return
                  if unlock_issue(num):
                      r2 = s.post(f"https://api.github.com/repos/{owner}/{repo}/issues/{num}/comments", json={"body": body})
                      if r2.status_code not in (200,201):
                          print(f"Warn: comment after UNLOCK failed for #{num}: {r2.status_code} {r2.text}")
                      relock_issue(num, reason)  # re-lock regardless
                  return

              # 4) other failures
              print(f"Warn: comment #{num} failed: {r.status_code} {r.text}")

          # messages + markers
          ACCEPT_MARKER = "<!-- ambassador-decision:accepted-2025 -->"
          REJECT_MARKER = "<!-- ambassador-decision:rejected-2025 -->"

          ACCEPT_MSG = (
            "Hello {name},\n\n"
            "Congratulations! ðŸŽ‰ We're excited to inform you that you have been selected as a 2025 PyTorch Ambassador. "
            "Your contributions, impact, and commitment to the PyTorch community stood out during the review process.\n\n"
            "You should also have received an invitation to join our private program management repository, "
            "where onboarding details and next steps will be shared. If you do not see the invite, please comment here and we will assist you.\n\n"
            "Best regards,\n"
            "The PyTorch PMO\n\n" + ACCEPT_MARKER
          )
          REJECT_MSG = (
            "Hello {name},\n\n"
            "Thank you for applying to the 2025 PyTorch Ambassador Program and for the valuable contributions you make in the PyTorch community. "
            "After careful consideration, we regret to inform you that your application was not selected in this cycle.\n\n"
            "We encourage you to apply again in the future â€” the next application cycle will open in early 2026. "
            "Please keep an eye on our website for updates on the timeline: https://pytorch.org/programs/ambassadors/\n\n"
            "We truly appreciate the time, effort, and passion you bring to the PyTorch community, and we hope to see your application again in the future.\n\n"
            "If you have any questions in the meantime, please feel free to reach out to us at ambassadors@pytorch.org.\n\n"
            "Best regards,\n"
            "The PyTorch PMO\n\n" + REJECT_MARKER
          )

          # ---- Iterate decision.csv rows and post per-row messages with Candidate name ----
          counts={"rows":0,"accept_commented":0,"reject_commented":0,"skipped":0}
          try:
              with open(dec_csv, newline="", encoding="utf-8") as f:
                  rdr = csv.DictReader(f)
                  hdr = {norm_key(h): h for h in (rdr.fieldnames or [])}
                  sid_key = hdr.get("submissionid") or hdr.get("issue") or hdr.get("issuenumber") or hdr.get("id")
                  decision_key = hdr.get("decision")
                  name_key = hdr.get("candidate")
                  if not sid_key or not decision_key or not name_key:
                      print("decision.csv must contain 'Submission ID', 'Decision', and 'Candidate' columns.", file=sys.stderr); sys.exit(1)

                  for idx,row in enumerate(rdr, start=2):
                      counts["rows"] += 1
                      raw_id = (row.get(sid_key) or "").strip()
                      decision_raw = (row.get(decision_key) or "").strip().lower()
                      candidate = (row.get(name_key) or "").strip() or "there"

                      if not raw_id:
                          counts["skipped"] += 1; continue
                      try:
                          num = int(float(raw_id))
                      except:
                          print(f"Row {idx}: invalid Submission ID '{raw_id}'; skipping.")
                          counts["skipped"] += 1; continue

                      labels = get_issue_labels(num)

                      if decision_raw in ("accept","accepted","approve","approved"):
                          if
